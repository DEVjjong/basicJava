package z_exam;

public class Exam_03 {
	public static void main(String[] args) {
		
//		[완료] [3-1] 다음 연산의 결과를 적으시오.
		
//		[연습문제]/ch3/Exercise3_1.java
		
//		int x = 2;
//		int y = 5;
//		char c = 'A'; // 'A'의 문자코드는 65
//		System.out.println(1 + x << 33);	//			: (1 + x << 33)연산중 1 + x먼저 계산을 하면 x는 2이므로 1 + 2 = 3이다. 즉 (1 << 33)이다. 이 의미는 3 * 2^33이다. 하지만 int형은 32비트이고, 32를 곱하면 제자리로 간다. 즉 33이므로 32를 가고 남은 값은 1이다. 다시말해 3 * 2^1이므로 3 * 2 = 6 이다.
//		System.out.println(y >= 5 || x < 0 && x > 2);//	: y는 5보다 작거나 같을때이니 5는 true, x는 0보다 크거나 2보다 작을때라는 뜻이므로 2는 false이다. 이걸 OR연산(||)하게 되면 true || false 이고, OR연산은 둘중 하나만 1의값(true)이면 1이기때문에, 결과값은 true이다.
//		System.out.println(y += 10 - x++);//			: y = y + 10과 같은의미이므로, y값은 15이고, x는 ++가 뒤에있어 나중에 연산이기때문에 x값은 2이다. 계산은 15-2 이므로 결과는 13이다.
//		System.out.println(x+=2);	//					: x = x + 2 와 같은 의미이므로, 3 + 2 = 5이다.
//		System.out.println( !('A' <= c && c <='Z') );//	: 'A'의 값이 c의값('A')보다 크거나 같냐 = 같다(true), c의값('A')이 'Z'보다 작거나 같냐 = 작다(true) 라는 계산값을 AND연산(&&)하게 되면 양쪽값이 true일때만 true이므로 둘은 일치 하기 때문에 true값이 나온다. 하지만 앞에 !(부정) 이 있어서 최종 결과값은 false가 나온다.
//		System.out.println('C'-c);		//				: 'C'는 유니코드로 변환하면 67의 값이고, 뒤의 c는 'A'의 값이 있으며 변환하면 65이다. 계산은 67-65 이므로 결과는 2가 나온다.
//		System.out.println('5'-'0');	//				: 5-0은 5이기때문에 값은 5가 나온다.
//		System.out.println(c+1);	//					: c = A(65)를 대입 하고, +1을 더하기 때문에 65+1 = 66이다.
//		System.out.println(++c);	//					: c = A(65)이고, ++가 앞에 있기때문에 먼저 연산(1증가) 후 대입이기에, c=B(66)이다.
//		System.out.println(c++);	//					: c = A(65)이지만, ++가 뒤에있어 대입 후 연산이기에 앞에서 이미 B(66)로 계산된 값을 대입하여, c=B(66)이다.
//		System.out.println(c);		//					: c = A(65)이지만 앞에서 대입 후 계산한 값 C(67)을 현재 위치에 대입하기 때문에 c=C(67)이다.
		
		

		
		
		
		
		
		
		
		
//		[완료] [3-2] 아래의 코드는 사과를 담는데 필요한 바구니(버켓)의 수를 구하는 코드이다. 만일
//		사과의 수가 123개이고 하나의 바구니에는 10개의 사과를 담을 수 있다면, 13개의 바구니
//		가 필요할 것이다. (1)에 알맞은 코드를 넣으시오.
		
//		int numOfApples = 123; // 사과의 개수
//		int sizeOfBucket = 10; // 바구니의 크기(바구니에 담을 수 있는 사과의 개수)
//		int numOfBucket = ( /* (1) */ ); // 모든 사과를 담는데 필요한 바구니의 수
//		int numOfBucket = ((numOfApples / sizeOfBucket) + ((numOfApples % sizeOfBucket) < 0 ? 0 : 1));		//정답
		
		/*
		1개의 바구니당 10개의 사과를 담을 수 있고, 총 123개의 사과를 담으려면 바구니 12개(사과120개)와 사과 3개가 남아서 1개의 바구니를 사용하여 총 13개의 바구니가 사용된다.
		이걸 수식으로 변환하면
		(사과 / 바구니) = (numOfApples / sizeOfBucket) 가 나오고 이값은 12이 나온다. 뒤의 소수점을 제거하고 13을 만들어야 하므로 삼항연산자를 사용한다.
		((사과 / 바구니) + (사과 % 바구니) < 0 ? 0 : 1) = ((numOfApples / sizeOfBucket) + ((numOfApples % sizeOfBucket) < 0 ? 0 : 1))
		이 뜻은 사과와 바구니의 나머지값은 3이고 이 값이 0보다 작으면 0으로 나오고, 0보다 크면 1이나온다.
		값은 0보다 작은값이 나올수 없으므로 앞의 계산과 뒤에 계산이 더하기(+)되어 계산된다.
		즉, ((123 / 10) + ((123 % 10) < 0 ? 0 : 1)) 으로 설명이 되고
		결과는 13이 나오게 된다.
		*/
		
//		System.out.println("필요한 바구니의 수 :"+numOfBucket);
//		System.out.println(numOfBucket);
		
//		[실행결과]
//		13
		
		
		
		
		
		
		
//		[완료] [3-3] 아래는 변수 num의 값에 따라 ‘양수’, ‘음수’, ‘0’을 출력하는 코드이다. 삼항 연산
//		자를 이용해서 (1)에 알맞은 코드를 넣으시오.
//		[Hint] 삼항 연산자를 두 번 사용하라.
		
//		int num = 10;
//		System.out.println( /* (1) */ );
//		System.out.println(num > 0 ? "양수" : num == 0 ? "0" : "음수");		//정답
		
		/*
		삼항연산자를 사용하여
		num 값이 0보다 클경우는 "양수"로 출력되고
		num 값이 0과 같으면 "0" 으로 출력
		0보다 작으면 "음수"로 출력
		*/
		
		
		
		
		
		
		
		
//		[완료] [3-4] 아래는 변수 num의 값 중에서 백의 자리 이하를 버리는 코드이다. 만일 변수 num
//		의 값이 ‘456’이라면 ‘400’이 되고, ‘111’이라면 ‘100’이 된다. (1)에 알맞은 코드를 넣으
//		시오.
		
//		int num = 456;
//		System.out.println( /* (1) */ );
//		System.out.println((num / 100) * 100);	//정답
		
		/*
		num값에 3자리 어떤수가 들어와도, 앞자리는 유지를 시키고 뒤에를 00으로 만들면 된다.
		이 뜻은 num을 100으로 나누면 앞자리만 나온다. 그래서 결과는 4가 나온다.
		뒤에 다시 00을 붙여야 하므로 여기에 100을 곱하면 400이 나온다.
		수식은 이러하다 : ((num / 100) * 100)
		*/
		
		
		
		
		
		
		
		
//		[완료] [3-5] 아래는 변수 num의 값 중에서 일의 자리를 1로 바꾸는 코드이다. 만일 변수 num의
//		값이 333이라면 331이 되고, 777이라면 771이 된다. (1)에 알맞은 코드를 넣으시오.
		
//		int num = 333;
//		System.out.println( /* (1) */ );
//		System.out.println( (int)((num / 10 + 0.1) * 10) );		//정답
		
		/*
		num값에 10을 나누면 두자리수가 되고 33이라는 값이나온다. 여기에 0.1을 더해 33.1을 만들고, 이 값에 10을 곱하면 331.0이 나오고,
		이 값을 int형 변수에 넣으면 331이 나온다. 
		*/
		
//		[실행결과]
//		331
		
		
		
		
		
		
		
		
		
		
//		[완료] [3-6] 아래는 변수 num의 값보다 크면서도 가장 가까운 10의 배수에서 변수 num의 값을
//		뺀 나머지를 구하는 코드이다. 예를 들어, 24의 크면서도 가장 가까운 10의 배수는 30이
//		다. 19의 경우 20이고, 81의 경우 90이 된다. 30에서 24를 뺀 나머지는 6이기 때문에 변
//		수 num의 값이 24라면 6을 결과로 얻어야 한다. (1)에 알맞은 코드를 넣으시오.
		
//		[Hint] 나머지 연산자를 사용하라.
		
//		int num = 24;
//		System.out.println( /* (1) */ );
//		System.out.println( 10 - (num % 10) );		//정답
		
		/*
		입력받은 num값을 10으로 나누면 끝에 나머지값만 남게 된다.
		여기서 10으로 빼면 10 - 4 이기 때문에, 정답은 6이 나온다.
		*/
//		[실행결과]
//		6

		
		
		
		
		
		
		
		  
		
//		[완료] [3-7] 아래는 화씨(Fahrenheit)를 섭씨(Celcius)로 변환하는 코드이다. 변환공식이 'C =
//		5/9 ×(F - 32)'라고 할 때, (1)에 알맞은 코드를 넣으시오. 단, 변환 결과값은 소수점
//		셋째자리에서 반올림해야한다.(Math.round()를 사용하지 않고 처리할 것)
//		
//		int fahrenheit = 100;
//		float celcius =  (int)((fahrenheit - 32) * 5 / 9F * 100 + 0.5) / 100F ;
//		System.out.println("Fahrenheit:" + fahrenheit);
//		System.out.println("Celcius:" + celcius);
		
		/*
		우선 변환공식에 따라 계산을 한다. (fahrenheit - 32) * 5 / 9F 소수점까지 표시를 위해 float인 F를 표시하였다(37.77778).
		여기에 100을 곱하게 되면 (3777.7778) 의 결과가 나온다.
		이 값에서 0.5F를 더하게 되면 (3778.2778) 가 나온다. 반올림을 하려면 0.5를 더하면 반올림이 된다.
		여기서 우리는 원래값에서 소수점 셋째자리 반올림 후 결과는 2번째자리까지 표시이기 때문에 여기에 100F를 나누면 된다.
		그러면 최종값은 37.78이 나오게 된다.
		*/
//		[실행결과]
//		Fahrenheit:100
//		Celcius:37.78
		
		
		
		
		
		
		
		
		
//		[완료][3-8] 아래 코드의 문제점을 수정해서 실행결과와 같은 결과를 얻도록 하시오.
		
//		byte a = 10;
//		byte b = 20;
		
////	byte c = a + b;
//		byte c = (byte)(a + b);		//  
		
//		char ch = 'A';
////	ch = ch + 2;
//		ch = (char)(ch + 2);		//
		
////	float f = 3 / 2;
//		float f = (float)3 / 2;	//
		
////	long l = 3000 * 3000 * 3000;
//		long l = 3000L * 3000 * 3000;	//
		
//		float f2 = 0.1f;
////	double d = 0.1;
		
//		boolean result = d==f2;
////	boolean result = (float)d==f2;
		
//		System.out.println("c="+c);
//		System.out.println("ch="+ch);
//		System.out.println("f="+f);
//		System.out.println("l="+l);
//		System.out.println("result="+result);
		
//		[실행결과]
//		c=30
//		ch=C
//		f=1.5
//		l=27000000000
//		result=true
		
		
		
		
		
		
		
		
//		[완료] [3-9] 다음은 문자형 변수 ch가 영문자(대문자 또는 소문자)이거나 숫자일 때만 변수 b
//		의 값이 true가 되도록 하는 코드이다. (1)에 알맞은 코드를 넣으시오.
		
//		char ch = 'z';
//		boolean b = ( /* (1) */ );
//		boolean b = ( 'A' <= ch && ch <= 'Z' || 'a' <= ch && ch <= 'z' || '0' <= ch && ch <= '9'  );		//정답
//		System.out.println(b);
		
		/*
		논리연산자(||,OR)를 사용하여 계산식을 작성하였다.
		우선 포함관계가 영문자(대문자 또는 소문자), 숫자일경우에만 true값을 출력하고, 나머지 문자일경우 false값을 출력하면 된다.
		영어 대문자의 경우 계산식은 ('A' <= ch && ch <= 'Z') 이러하고
		영어 소문자의 경우 계산식은 ('a' <= ch && ch <= 'z' || '0') 이러하고
		숫자의 경우 계산식은 ('0' <= ch && ch <= '9') 이다.
		이 모든것을 OR연산으로(||) 묶으면 된다.
		*/
		
//		[실행결과]
//		true
		
		
		
		
		
		
		
//		[완료] [3-10] 다음은 대문자를 소문자로 변경하는 코드인데, 문자 ch에 저장된 문자가 대문자
//		인 경우에만 소문자로 변경한다. 문자코드는 소문자가 대문자보다 32만큼 더 크다. 예를
//		들어 'A'의 코드는 65이고 'a'의 코드는 97이다. (1)~(2)에 알맞은 코드를 넣으시오.
		
//		char ch = 'A';
//		char lowerCase = ( /* (1) */ ) ? ( /* (2) */ ) : ch;
//		char lowerCase = ( 'A'<= ch && 'Z' >= ch ) ? ( ch = (char)(ch + 32) ) : ch;		//정답
//		System.out.println("ch:"+ch);
//		System.out.println("ch to lowerCase:"+lowerCase);
		
//		[실행결과]
//		ch:A
//		ch to lowerCase:a
		
		/*
		문제는 대문자를 입력받으면 소문자로 변경을 해야하는 코드를 작성해야 한다.
		예를들어 대문자 A는 65이고, 소문자 a는 97이다. 이 둘은 32의 차이가 있으며, 입력받은 값에 32를 더하면 소문자로 나온다.
		삼항연산자를 사용하면 된다.
		우선 입력받은 값이 대문자인지 소문자인지를 판단하려면 ('A'<= ch && 'Z' >= ch) 이렇게 코드를 작성하면 되고, 여기서 대문자인경우 입력받은 값에서 32를 더하고 소문자로 입력받은 경우 그대로 출력하는 코드를 작성한다.
		( ch = (char)(ch + 32) ) : ch 이렇게 코드를 작성하면 대문자인경우 32를 더해 소문자로 출력하면되고, 소문자로 입력을 받았으면 그대로 소문자로 출력하면 된다.
		최종 완성 코드는 다음과 같다.
		( 'A'<= ch && 'Z' >= ch ) ? ( ch = (char)(ch + 32) ) : ch;
		 */
		
		
		
	}

}
